package journald

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	"log/slog"

	"github.com/runreveal/kawa"
	"github.com/runreveal/reveald/internal"
	"github.com/runreveal/reveald/internal/types"
)

type Journald struct {
	msgC                chan kawa.MsgAck[types.Event]
	maxLineLenKB        int
	unescapeMessageJSON bool
}

type Option func(*Journald)

func WithMaxLineLenKB(maxLineLenKB int) Option {
	return func(j *Journald) {
		j.maxLineLenKB = maxLineLenKB
	}
}

func WithUnescapeMessageJSON(unescape bool) Option {
	return func(j *Journald) {
		j.unescapeMessageJSON = unescape
	}
}

func New(opts ...Option) *Journald {
	j := &Journald{
		msgC:         make(chan kawa.MsgAck[types.Event]),
		maxLineLenKB: 64, // default
	}
	for _, opt := range opts {
		opt(j)
	}
	return j
}

func (s *Journald) Run(ctx context.Context) error {
	return s.recvLoop(ctx)
}

func (s *Journald) recvLoop(ctx context.Context) error {
	// Open file to check and save high watermark
	hwmFile, err := os.OpenFile(
		filepath.Join(internal.ConfigDir(), "kawad-journald-hwm"),
		os.O_RDWR|os.O_CREATE,
		os.FileMode(0644),
	)
	if err != nil {
		return err
	}
	defer hwmFile.Close()

	// Read high watermark from file
	bts, err := io.ReadAll(hwmFile)
	if err != nil {
		return err
	}

	// Save high watermark to file
	ack := func(cursor string) {
		var err error
		defer func() {
			if err != nil {
				slog.Error(fmt.Sprintf("writing high watermark: %+v", err))
			}
		}()
		err = hwmFile.Truncate(0)
		if err != nil {
			return
		}
		_, err = hwmFile.Seek(0, 0)
		if err != nil {
			return
		}
		_, err = hwmFile.WriteString(cursor)
		if err != nil {
			return
		}
	}

	args := []string{
		"journalctl", "-b", "-af", "-o", "json",
	}
	if len(bts) > 0 {
		// Resume reading from the location of a previous invocation
		args = append(args, "--after-cursor", string(bts))
	} else {
		// Read all logs for this boot
		args = append(args, "--since", "1970-01-01 00:00:00")
	}
	slog.Debug(fmt.Sprintf("running: `%s`", strings.Join(args, " ")))

	cmd := exec.Command(args[0], args[1:]...)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return err
	}
	if err := cmd.Start(); err != nil {
		return err
	}
	scanner := bufio.NewScanner(stdout)
	// Configure scanner buffer with the specified maximum line length
	maxLineLen := s.maxLineLenKB * 1024 // convert KB to bytes
	scanner.Buffer(make([]byte, maxLineLen), maxLineLen)
	var wg sync.WaitGroup

	slog.Info("reading journald")

loop:
	for scanner.Scan() {
		bts := make([]byte, len(scanner.Bytes()))
		copy(bts, scanner.Bytes())

		// Parse timestamp from log
		log := autoGeneratedJournal{}
		var ts time.Time
		if err := json.Unmarshal(bts, &log); err != nil {
			slog.Error(fmt.Sprintf("unmarshaling: %+v", err))
			continue
		} else {
			ts, err = parseUnixMicroseconds(log.RealtimeTimestamp)
			if err != nil {
				slog.Error(fmt.Sprintf("parsing timestamp: %+v", err))
			}
		}

		// Attempt to unescape MESSAGE field if enabled and it contains JSON
		if s.unescapeMessageJSON {
			bts = s.unescapeMessage(bts, log.Message)
		}

		wg.Add(1)
		select {
		case s.msgC <- kawa.MsgAck[types.Event]{
			Msg: kawa.Message[types.Event]{
				Value: types.Event{
					EventTime:  ts,
					SourceType: "journald",
					RawLog:     bts,
				},
			},
			Ack: func() {
				ack(log.Cursor)
				wg.Done()
			},
		}:
		case <-ctx.Done():
			break loop
		}
	}
	if err := scanner.Err(); err != nil {
		return fmt.Errorf("scanning: %+w", err)
	}

	slog.Info("waiting for journald to exit")

	c := make(chan struct{})
	go func() {
		wg.Wait()
		close(c)
	}()

	select {
	// We've received all the logs
	case <-c:
	case <-ctx.Done():
		return ctx.Err()
	}
	return cmd.Wait()
}

func (s *Journald) Recv(ctx context.Context) (kawa.Message[types.Event], func(), error) {
	select {
	case <-ctx.Done():
		return kawa.Message[types.Event]{}, nil, ctx.Err()
	case pass := <-s.msgC:
		return pass.Msg, pass.Ack, nil
	}
}

func parseUnixMicroseconds(s string) (time.Time, error) {
	microseconds, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		return time.Time{}, err
	}

	// Convert microseconds to seconds and remainder microseconds
	sec := microseconds / 1e6
	nsec := (microseconds % 1e6) * 1e3

	// Create a new time.Time value
	return time.Unix(sec, nsec), nil
}

type journalMsg []byte

func (jm *journalMsg) UnmarshalJSON(b []byte) error {
	if len(b) == 0 {
		return errors.New("unexpected end of JSON input for journalMsg")
	}
	var err error
	switch b[0] {
	case '"':
		var s string
		err = json.Unmarshal(b, &s)
		if err != nil {
			return err
		}
		*jm = []byte(s)
	case '[':
		var bts []byte
		err = json.Unmarshal(b, &bts)
		if err != nil {
			return err
		}
		*jm = bts
	default:
		err = fmt.Errorf("unexpected character in journalMsg: %s. expecting string or list", string(b[0]))
	}
	return err
}

// There are other fields, but these should be on just about every journald event
type autoGeneratedJournal struct {
	Message journalMsg `json:"MESSAGE"`
	// Unix Timestamp in Microseconds since epoch as string
	RealtimeTimestamp string `json:"__REALTIME_TIMESTAMP"`
	SyslogIdentifier  string `json:"SYSLOG_IDENTIFIER"`
	Hostname          string `json:"_HOSTNAME"`
	Cursor            string `json:"__CURSOR"`

	// BootID             string `json:"_BOOT_ID"`
	// CapEffective       string `json:"_CAP_EFFECTIVE"`
	// Cmdline            string `json:"_CMDLINE"`
	// Comm               string `json:"_COMM"`
	// Exe                string `json:"_EXE"`
	// Gid                string `json:"_GID"`
	// MachineID          string `json:"_MACHINE_ID"`
	// MonotonicTimestamp string `json:"__MONOTONIC_TIMESTAMP"`
	// Pid                string `json:"_PID"`
	// Priority           string `json:"PRIORITY"`
	// SelinuxContext     string `json:"_SELINUX_CONTEXT"`
	// SyslogFacility     string `json:"SYSLOG_FACILITY"`
	// SystemdCgroup      string `json:"_SYSTEMD_CGROUP"`
	// SystemdSlice       string `json:"_SYSTEMD_SLICE"`
	// SystemdUnit        string `json:"_SYSTEMD_UNIT"`
	// Transport          string `json:"_TRANSPORT"`
	// UID                string `json:"_UID"`
}

// unescapeMessage attempts to unescape the MESSAGE field if it contains escaped JSON.
// If MESSAGE contains valid JSON (escaped or not), it will be parsed and reconstructed
// in the journald JSON with the MESSAGE field as a JSON object rather than a string.
// Returns the modified bytes if successful, or the original bytes on any error.
func (s *Journald) unescapeMessage(originalBytes []byte, message journalMsg) []byte {
	// Skip empty messages
	if len(message) == 0 {
		return originalBytes
	}

	// Check if MESSAGE looks like JSON (starts with { or [)
	firstByte := message[0]
	if firstByte != '{' && firstByte != '[' {
		return originalBytes
	}

	// Check if MESSAGE in the original JSON is a string (not already an object/array)
	// This ensures we only unescape actual escaped JSON strings
	var journaldData map[string]any
	if err := json.Unmarshal(originalBytes, &journaldData); err != nil {
		slog.Error(fmt.Sprintf("failed to unmarshal journald JSON: %+v", err))
		return originalBytes
	}

	// If MESSAGE is already an object or array (not a string), leave it as-is
	if _, isString := journaldData["MESSAGE"].(string); !isString {
		return originalBytes
	}

	// Try to parse MESSAGE as JSON
	var parsedMessage any
	if err := json.Unmarshal(message, &parsedMessage); err != nil {
		// Not valid JSON, leave as-is
		slog.Debug(fmt.Sprintf("MESSAGE field is not valid JSON: %+v", err))
		return originalBytes
	}

	// Replace MESSAGE field with the parsed JSON object
	journaldData["MESSAGE"] = parsedMessage

	// Add indicator that MESSAGE was successfully parsed as JSON
	journaldData["_MESSAGE_IS_JSON"] = true

	// Marshal back to JSON
	modifiedBytes, err := json.Marshal(journaldData)
	if err != nil {
		slog.Error(fmt.Sprintf("failed to marshal modified journald JSON: %+v", err))
		return originalBytes
	}

	return modifiedBytes
}
